{"version":3,"sources":["index.js"],"names":["global","factory","exports","module","require","this$1","this","arguments","length","args","Array","SyntaxError","forEach","arg","console","warn","const","el","remove","scrollBarWidth","let","ref","element","getBoundingClientRect","top","bottom","left","right","tolerance","viewport","window","options","isVisibleFlag","$viewport","settings","jquery","$","$viewportWidth","width","typeofViewport","viewportRect","isInViewport","getSelectorArgs","argsString","split","isNaN","filter","i","fn","run"],"mappings":"CAAA,SAAQA,EAAMC,GACK,gBAAZC,UAAoB,mBAAAC,QAAAF,EAAAG,QAAA,UAAAA,QAAA,6JAgCzB,GAAIC,GAAMC,QAET,IAAAC,UAAAC,QAAA,kBAAAC,cAIGA,YAAaC,aACb,IAAQC,aAAK,uGAGdC,QAAA,SAAAC,GACD,kBAAAA,+GAEFC,QAAWC,KAAA,kLAcXC,MAAM,8CAUN,OADFC,GAAAC,SACgCC,kBAE9BC,GAAIC,GAAAC,EAAaC,wBACfC,EAAAH,EAAYG,IACZC,EAAUJ,EAAAI,OACTC,EAAQL,EAAAK,KACPC,EAAAN,EAAAM,kBAGJC,UAAK,EACHC,SAAQC,GACRC,GACAC,GAAc,EACfC,EAAAC,EAAAL,SAAAM,OAAAD,EAAAL,SAAAO,EAAAF,EAAAL,SAEKI,GAAAzB,SACNY,QAAIL,KAAA,qFACJC,QAAMD,KAAA,2EAKFsB,EAAiBJ,EAAUK,6BAM7BL,EAAY,KAAAH,GAAgB,oBAAAS,GAAA,uBAAAA,EAAA,CAG5B,GAAAC,GAAgBP,EAAa,GAAAV,uBAG7BC,IAAYgB,EAAChB,uBAGbG,GAAca,EAAId,6CAMpBW,GAAkBI,EAAetB,8HAqB1Ba,iEAWHU,GAAiBC,MACjBA,EAAU,IACXlC,GAAAkC,EAAAC,MAAA,IAQJ,OALuB,KAAlBnC,EAAAD,QAAqBqC,MAAQpC,EAAI,MACjCA,EAAA,GAAUA,EAAK,GAChBA,EAAA,GAAA;;;;oMA5HL,MAASH,MAAIwC,OAAO,SAAAC,EAAA9B,GAAA,MAAAwB,GAAAxB,EAAAc,QAClBiB,GAAAC,IAAIA","file":"isInViewport.min.js","sourcesContent":["import $ from 'jquery'\nimport window from 'window'\n\n/**\n * @author  Mudit Ameta\n * @license https://github.com/zeusdeux/isInViewport/blob/master/license.md MIT\n */\n\n// expose isInViewport as a custom pseudo-selector\n$.extend($.expr[':'], {\n  // if $.expr.createPseudo is available, use it\n  'in-viewport': $.expr.createPseudo\n    ? $.expr.createPseudo(argsString => currElement => isInViewport(currElement, getSelectorArgs(argsString)))\n  : (currObj, index, meta) => isInViewport(currObj, getSelectorArgs(meta[3]))\n})\n\n\n// expose isInViewport as a function too\n// this lets folks pass around actual objects as options (like custom viewport)\n// and doesn't tie 'em down to strings. It also prevents isInViewport from\n// having to look up and wrap the dom element corresponding to the viewport selector\n$.fn.isInViewport = function(options) {\n  return this.filter((i, el) => isInViewport(el, options))\n}\n\n$.fn.run = run\n\n// lets you chain any arbitrary function or an array of functions and returns a jquery object\nfunction run(args) {\n  if (arguments.length === 1 && typeof args === 'function') {\n    args = [args]\n  }\n\n  if (!(args instanceof Array)) {\n    throw new SyntaxError('isInViewport: Argument(s) passed to .do/.run should be a function or an array of functions')\n  }\n\n  args.forEach(arg => {\n    if (typeof arg !== 'function') {\n      console.warn('isInViewport: Argument(s) passed to .do/.run should be a function or an array of functions')\n      console.warn('isInViewport: Ignoring non-function values in array and moving on')\n    } else {\n      [].slice.call(this).forEach(t => arg.call($(t)))\n    }\n  })\n\n  return this\n}\n\n\n// gets the width of the scrollbar\nfunction getScrollbarWidth(viewport) {\n  // append a div that has 100% width to get true width of viewport\n  const el = $('<div></div>').css({\n    width: '100%'\n  })\n  viewport.append(el)\n\n  // subtract true width from the viewport width which is inclusive\n  // of scrollbar by default\n  const scrollBarWidth = viewport.width() - el.width()\n\n  // remove our element from DOM\n  el.remove()\n  return scrollBarWidth\n}\n\n\n// Returns true if DOM element `element` is in viewport\nfunction isInViewport(element, options) {\n  let {top, bottom, left, right} = element.getBoundingClientRect()\n\n  let settings = $.extend({\n    tolerance: 0,\n    viewport: window\n  }, options)\n  let isVisibleFlag = false\n  let $viewport = settings.viewport.jquery ? settings.viewport : $(settings.viewport)\n\n  if (!$viewport.length) {\n    console.warn('isInViewport: The viewport selector you have provided matches no element on page.')\n    console.warn('isInViewport: Defaulting to viewport as window')\n    $viewport = $(window)\n  }\n\n  const $viewportHeight = $viewport.height()\n  let $viewportWidth = $viewport.width()\n  const typeofViewport = $viewport[0].toString()\n\n  // if the viewport is other than window recalculate the top,\n  // bottom,left and right wrt the new viewport\n  // the [object DOMWindow] check is for window object type in PhantomJS\n  if ($viewport[0] !== window && typeofViewport !== '[object Window]' && typeofViewport !== '[object DOMWindow]') {\n    // use getBoundingClientRect() instead of $.Offset()\n    // since the original top/bottom positions are calculated relative to browser viewport and not document\n    const viewportRect = $viewport[0].getBoundingClientRect()\n\n    // recalculate these relative to viewport\n    top = top - viewportRect.top\n    bottom = bottom - viewportRect.top\n    left = left - viewportRect.left\n    right = right - viewportRect.left\n\n    // get the scrollbar width from cache or calculate it\n    isInViewport.scrollBarWidth = isInViewport.scrollBarWidth || getScrollbarWidth($viewport)\n\n    // remove the width of the scrollbar from the viewport width\n    $viewportWidth -= isInViewport.scrollBarWidth\n  }\n\n  // handle falsy, non-number and non-integer tolerance value\n  // same as checking using isNaN and then setting to 0\n  // bitwise operators deserve some love too you know\n  settings.tolerance = ~~Math.round(parseFloat(settings.tolerance))\n\n  if (settings.tolerance < 0) {\n    settings.tolerance = $viewportHeight + settings.tolerance // viewport height - tol\n  }\n\n  // the element is NOT in viewport iff it is completely out of\n  // viewport laterally or if it is completely out of the tolerance\n  // region. Therefore, if it is partially in view then it is considered\n  // to be in the viewport and hence true is returned. Because we have adjusted\n  // the left/right positions relative to the viewport, we should check the\n  // element's right against the viewport's 0 (left side), and the element's\n  // left against the viewport's width to see if it is outside of the viewport.\n\n  if (right <= 0 || left >= $viewportWidth) {\n    return isVisibleFlag\n  }\n\n  // if the element is bound to some tolerance\n  isVisibleFlag = settings.tolerance ? top <= settings.tolerance && bottom >= settings.tolerance : bottom > 0 && top <= $viewportHeight\n\n  return isVisibleFlag\n}\n\n\n// get the selector args from the args string proved by Sizzle\nfunction getSelectorArgs(argsString) {\n  if (argsString) {\n    const args = argsString.split(',')\n\n    // when user only gives viewport and no tolerance\n    if (args.length === 1 && isNaN(args[0])) {\n      args[1] = args[0]\n      args[0] = void 0\n    }\n\n    return {\n      tolerance: args[0] ? args[0].trim() : void 0,\n      viewport: args[1] ? $(args[1].trim()) : void 0\n    }\n  }\n  return {}\n}\n"]}